# Архитектура вычислительных систем ИДЗ 1

0. [**Задание**](#задание)
0. [**Отчёт**](#отчёт)
    + [*4 балла*](#4-балла)
    + [*5 баллов*](#5-баллов)
    + [*6 баллов*](#6-баллов)
    + [*7 баллов*](#7-баллов)
    + [*8 баллов*](#8-баллов)
    + [*9 баллов*](#9-баллов)
0. [**Дерево проекта**](#дерево-проекта)
0. [**Инструкции по запуску**](#инструкции-по-запуску)

## Задание

*Разработать программу, которая получает одномерный массив AN, после чего формирует из элементов массива A новый массив B по правилам, указанным в варианте, и выводит его. Память под массивы может выделяться статически, на стеке, автоматичеси по выбору разработчика. При решении задачи необходимо использовать подпрограммы для реализации ввода, вывода и формирования нового массива.*

*Вариант 25. Сформировать массив B из элементов массива A заменив все положительные числа значением 2, а отрицательные — увеличить на 5.*

## Отчёт

**Делала на оценку 9 баллов**

Для удобства проверки структурировала отчёт по критериям

### 4 балла

+ *Приведено решение задачи на C.*

    Код на C находится в `main.c` и `form_array.c`

    Скомпилированная программа на C находится в `c.exe`

+ *В полученную ассемблерную программу, откомпилированную без оптимизирующих и отладочных опций, добавлены комментарии, поясняющие эквивалентное представление переменных в программе на C.*

    Полностью прокомментированная ассемблерная программа находится в `main.s` и `form_array.s`

    Скомпилированная ассемблерная программа находится в `asm.exe`

    Пример комментария, поясняющего эквивалентное представление переменных:
    ```
	mov	r15d, edi					# записываем в регистр: n (int - 4 byte)
	mov	r13, rsi					# записываем в регистр: A (int* - 8 byte)
	mov	r14, rdx					# записываем в регистр: B (int* - 8 byte)
	mov	r12d, 0						# записываем в регистр: i = 0 (int - 4 byte)
    ```

+ *Из ассемблерной программы убраны лишние макросы за счет использования соответствующих аргументов командной строки и/или за счет ручного редактирования исходного текста ассемблерной программы.*

    Ассемблерная программа сразу после получения ассемблера находится в `stages/main.bare.s` и `stages/form_array.bare.s`

    Использованы соответствующие аргументы командной строки, которые указаны в `scripts/make-asm.sh`

    За счёт ручного редактирования ассемблерной программы размер `main.s` сократился с 243 строк до 204

    Примеры удалённого из `main.s`:
    ```
    .file	"main.c"
    ```
    ```
	.type	main, @function
    ```
    ```
	cdqe                            # знаковое расширение, входило 5 раз
    ```
    ```
    mov	QWORD PTR -8[rbp], rax      # и много подобных конструкций
	mov	rax, QWORD PTR -8[rbp]
    ```
    ```
    .size	timeDelta, .-timeDelta
    ```
    ```
	mov	rdi, r9
    ```
    ```
	.ident	"GCC: (GNU) 10.3.1 20210703 (ALT Sisyphus 10.3.1-alt2)"
	.section	.note.GNU-stack,"",@progbits
    ```

    Примеры удалённого из `form_array.s`:
    ```
    .file	"form_array.c"
    ```
    ```
	.type	form_array, @function
    ```
    ```
	cdqe                            # знаковое расширение, входило 6 раз
    ```
    ```
	.ident	"GCC: (GNU) 10.3.1 20210703 (ALT Sisyphus 10.3.1-alt2)"
	.section	.note.GNU-stack,"",@progbits
    ```

    Примеры оптимизации в `main.s`

    +   Было:
        ```
        mov	rax, QWORD PTR [rax]
        mov	rdi, rax
        ```
        Стало:
        ```
        mov	rdi, QWORD PTR [rax]
        ```

    +   Было:
        ```
        mov	r8, rdi
        mov	rsi, r8
        ```
        Стало:
        ```
        mov	rsi, rdi
        ```
    +   Было:
        ```
        mov	rax, QWORD PTR -80[rbp]
        mov	rdx, QWORD PTR -72[rbp]
        mov	rdi, QWORD PTR -96[rbp]
        mov	rsi, QWORD PTR -88[rbp]
        mov	rcx, rdx
        mov	rdx, rax
        ```
        Стало:
        ```
        mov	rdx, QWORD PTR -80[rbp]		# получаем start.tv_sec со стека
        mov	rcx, QWORD PTR -72[rbp]		# получаем start.tv_nsec со стека
        mov	rdi, QWORD PTR -96[rbp]		# получаем finish.tv_sec со стека
        mov	rsi, QWORD PTR -88[rbp]		# получаем finish.tv_nsec со стека
        ```

+ *Модифицированная ассемблерная программа отдельно откомпилирована и скомпонована без использования опций отладки.*

    Скомпилированная ассемблерная программа находится в `asm.exe`

+ *Представлено полное тестовое покрытие, дающее одинаковый результат на обоих программах. Приведены результаты тестовых прогонов для обоих программ, демонстрирующие эквивалентность функционирования.*

    Тесты находятся в `tests/`. Их 4, размеры соответственно 5, 10, 1000 и 2000 чисел в массиве. Последние два теста сгенерированы моей же программой на ассемблере с помощью генератора рандомных чисел

    Результаты прогонов (в скрипте есть печать diff, поэтому результаты работы программ на С и на ассемблере идентичны и совпадают с эталонным ответом)
    ```
    $ make test
    echo "Test ASM"
    Test ASM
    make test.asm
    bash ./scripts/test-asm.sh
    Test 1
    Time delta: 30573650 ns


    Test 2
    Time delta: 65420753 ns


    Test 3
    Time delta: 6087599994 ns


    Test 4
    Time delta: 10279693573 ns


    echo "Test C"
    Test C
    make test.c
    bash ./scripts/test-c.sh
    Test 1
    Time delta: 58242082 ns


    Test 2
    Time delta: 89953778 ns


    Test 3
    Time delta: 6184423906 ns


    Test 4
    Time delta: 14661388234 ns
    ```

+ *Сформировать отчет, описывающий результаты тестовых прогонов и используемых опций компиляции и/или описания проведенных модификаций.*

    Отчёт сформирован

### 5 баллов

+ *В реализованной программе использовать функции с передачей данных через параметры.*

    Функция `form_array(int n, int *A, int *B)` использует передачу данных через параметры, в ассемблерной программе эта функция работает аналогично

+ *Использовать локальные переменные.*

    Пример использования локальной переменной в `main.c`:
    ```
    int count = 1000000;
    ```
    и её же в `main.s`:
    ```
    mov	DWORD PTR -28[rbp], 1000000	# кладём на стек: count = 10000 (int - 4 byte)
    ```

+ *В ассемблерную программу при вызове функции добавить комментарии, описывающие передачу фактических параметров и перенос возвращаемого результата.*

    Полностью прокомментированная ассемблерная программа находится в `main.s` и `form_array.s`

    Пример комментария, описывающего передачу фактических параметров:
    ```
    mov	edi, DWORD PTR -60[rbp]		# получаем n со стека
	mov	rdx, QWORD PTR -48[rbp]		# получаем B со стека
	mov	rsi, QWORD PTR -40[rbp]		# получаем A со стека
	call	form_array@PLT			# вызов form_array()
    ```
    Пример комментария, описывающего перенос возвращаемого результата:
    ```
	call	fopen@PLT               # вызываем fopen()
	mov	QWORD PTR -24[rbp], rax     # output = fopen(argv[3], "w");
    ```

+ *В функциях для формальных параметров добавить комментарии, описывающие связь между параметрами языка Си и регистрами (стеком).*

    Полностью прокомментированная ассемблерная программа находится в `main.s` и `form_array.s`

    Пример комментария, описывающего связь между параметрами языка Си и регистрами (стеком):
    ```
    mov	rdx, QWORD PTR -80[rbp]		# получаем start.tv_sec со стека
	mov	rcx, QWORD PTR -72[rbp]		# получаем start.tv_nsec со стека
	mov	rdi, QWORD PTR -96[rbp]		# получаем finish.tv_sec со стека
	mov	rsi, QWORD PTR -88[rbp]		# получаем finish.tv_nsec со стека
    ```

+ *Добавить информацию о проведенных изменениях в отчет.*

    Информация добавлена в отчёт

### 6 баллов

+ *Рефакторинг программы на ассемблере за счет максимального использования регистров процессора. Добавление этой программы к уже представленным.*

    Так как в основной программе многократно вызывает функция `form_array`, то использование регистров процессора было сделано в ней, а именно были произведены следующие замены:
    ```
    rbp[-4]  -> r12d
    rbp[-32] -> r13
    rbp[-40] -> r14
    rbp[-20] -> r15d
    ```
    В результате вместо
    ```
    mov	DWORD PTR -20[rbp], edi
	mov	QWORD PTR -32[rbp], rsi
	mov	QWORD PTR -40[rbp], rdx
	mov	DWORD PTR -4[rbp], 0
    ```
    получили
    ```
    mov	r15d, edi					# записываем в регистр: n (int - 4 byte)
	mov	r13, rsi					# записываем в регистр: A (int* - 8 byte)
	mov	r14, rdx					# записываем в регистр: B (int* - 8 byte)
	mov	r12d, 0						# записываем в регистр: i = 0 (int - 4 byte)
    ```

    Программа после рефакторинга находится в `main.s` и `form_array.s`

    Исходная ассемблерная программа находится в `stages/main.bare.s` и `stages/form_array.bare.s`

+ *Добавление комментариев в разработанную программу, поясняющих эквивалентное использование регистров вместо переменных исходной программы на C.*

    Полностью прокомментированная ассемблерная программа находится в `main.s` и `form_array.s`

    Пример комментария, описывающего эквивалентное использование регистров вместо переменных исходной программы на C:
    ```
    mov	r15d, edi					# записываем в регистр: n (int - 4 byte)
	mov	r13, rsi					# записываем в регистр: A (int* - 8 byte)
	mov	r14, rdx					# записываем в регистр: B (int* - 8 byte)
	mov	r12d, 0						# записываем в регистр: i = 0 (int - 4 byte)
    ```

+ *Представление результатов тестовых прогонов для разработанной программы. Оценка корректности ее выполнения на основе сравнения тестовых прогонов результатами тестирования предшествующих программ.*

    Результат тестового прогона (diff ничего не вывел - всё хорошо):
    ```
    $ make test.asm
    bash ./scripts/test-asm.sh
    Test 1
    Time delta: 26114418 ns


    Test 2
    Time delta: 72934853 ns


    Test 3
    Time delta: 3852277533 ns


    Test 4
    Time delta: 9534220042 ns
    ```

+ *Добавить новую информацию в отчет.*

    Информация добавлена в отчёт

### 7 баллов

+ *Реализация программы на ассемблере, полученной после рефакторинга, в виде двух или более единиц компиляции.*

    Использованы две единицы компиляции:
    + `main.s`
    + `form_array.s`

+ *Задание файлов с исходными данными и файла для вывода результатов с использованием аргументов командной строки.*

    Использованы аргументы командной строки для задания входного и выходного файлов:
    ```
    input = fopen(argv[2], "r");
    output = fopen(argv[3], "w");
    fscanf(input, "%d", &n);
    ```

+ *Добавить в отчет информацию о проделанных изменениях и результаты работы с тестовыми файлами.*

    Информация добавлена в отчёт

### 8 баллов

+ *Добавление в программу генератора случайных наборов данных, расширяющих возможности тестирования. Подключение генератора к программе с выбором в командной строке варианта ввода данных.*

    Вариант ввода данных выбирается с помощью первого аргумента командной строки:
    + `0` - ввод из указанного во втором аргументе файла, вывод в указанный третьим аргументом файл
    + `1` - ввод с помощью генератора, количество чисел в массиве задаётся вторым аргументом, сгенерированный массив А выводится в `input`, сформированный массив В выводится в `output`
 
    Получение размера массива:
    ```
    if (atoi(argv[1]) == 0) {
        input = fopen(argv[2], "r");
        output = fopen(argv[3], "w");
        fscanf(input, "%d", &n);
    } else {
        input = fopen("input", "w");
        output = fopen("output", "w");
        n = atoi(argv[2]);
    }
    ```

    Ввод массива А:
    ```
    if (atoi(argv[1]) == 0) {
        for(i = 0; i < n; i++) {
            fscanf(input, "%d", &A[i]);
        }
    } else {
        for(i = 0; i < n; i++) {
            A[i] = rand() % 200 - 100;
            fprintf(input, "%d ", A[i]);
    }
    ```

+ *Расширение анализа командной строки для выбора способа порождения исходных данных. Добавление данных, порождаемых генератором.*

    Описано в предыдущем пункте

+ *Модификация программы на C и программы на ассемблере, полученной после рефакторинга, для проведения сравнения на производительность. Необходимо добавить замеры во времени, которые не учитывают время ввода и вывода данных. Для увеличения времени работы минимум до 1 секунды, в зависимости от особенностей программы, можно либо выбирать соответствующие размеры исходных данных, либо зацикливать для многократного выполнения ту часть программы, которая выполняет вычисления.*

    Замер времени выполнения без ввода-вывода:
    ```
    clock_gettime(CLOCK_MONOTONIC, &start);

    for(i = 0; i < COUNT; i++) {
        form_array(n, A, B);
    }

    clock_gettime(CLOCK_MONOTONIC, &finish);

    time_delta = timeDelta(finish, start);
    printf("Time delta: %ld ns\n", time_delta);
    ```

    Вычисления программы выполняются `count = 1000000` раз

    Результат тестового прогона со сравнением работы программы на C и ассемблерной программы
    ```
    $ make compare
    bash ./scripts/compare.sh
    Test 1
    ~~~ASM-program~~~
    Time delta: 27926987 ns
    ~~~~C-program~~~~
    Time delta: 26356725 ns

    Test 2
    ~~~ASM-program~~~
    Time delta: 61166692 ns
    ~~~~C-program~~~~
    Time delta: 57593824 ns

    Test 3
    ~~~ASM-program~~~
    Time delta: 4857051526 ns
    ~~~~C-program~~~~
    Time delta: 5896887238 ns

    Test 4
    ~~~ASM-program~~~
    Time delta: 9537902233 ns
    ~~~~C-program~~~~
    Time delta: 11996438916 ns
    ```
    Видим, что ассемблерная программа работает быстрее на больших входных данных (массив А 1000-2000 элементов)

+ *Представить полученные данные в отчете для разных вариантов тестовых прогонов*

    Информация добавлена в отчёт


### 9 баллов

+ *Используя опции оптимизации по скорости, сформировать из модифицированной программы на C исходный код ассемблере. Провести сравнительный анализ с предыдущими ассемблерными программами по размеру ассемблерного кода, размеру исполняемого файла и производительности.*

    Для оптимизации по скорости использовались флаги `-O0` `-O1` `-O2` `-O3` `-Ofast`, также для сравнения представлены программа, скомпилированная без флагов оптимизации и опитимизированная мной программа (последняя версия с комментариями)

    Скрипт для формирования программ с использованием опций оптимизации находится в `scripts/optimize.sh`

    Результат сравнительного анализа:
    ```
    $ make compare.opt
    bash ./scripts/compare-opt.sh
    ~~~Test non-optimization~~~
    Number of lines: 350
    Size in bytes: 6118
    Time delta: 17538259543 ns

    ~~~Test o0-optimization~~~
    Number of lines: 350
    Size in bytes: 6118
    Time delta: 16984224436 ns

    ~~~Test o1-optimization~~~
    Number of lines: 251
    Size in bytes: 4285
    Time delta: 2960131342 ns

    ~~~Test o2-optimization~~~
    Number of lines: 268
    Size in bytes: 4638
    Time delta: 2640930718 ns

    ~~~Test o3-optimization~~~
    Number of lines: 379
    Size in bytes: 6382
    Time delta: 1562916418 ns

    ~~~Test ofast-optimization~~~
    Number of lines: 379
    Size in bytes: 6382
    Time delta: 1507756943 ns

    ~~~Test os-optimization~~~
    Number of lines: 234
    Size in bytes: 3999
    Time delta: 14576964971 ns

    ~~~Test my-optimization~~~
    Number of lines: 267
    Size in bytes: 18120
    Time delta: 8290021364 ns
    ```

    Вывод: моя программа работает быстрее, чем программы без оптимизации и с флагами `-00`, `-Os`

+ *Аналогично, используя опции оптимизации по размеру, сформировать код на ассемблере. Провести сравнительный анализ с предыдущими ассемблерными программами по размеру ассемблерного кода, размеру исполняемого файла и производительности.*

    Для оптимизации по размеру использовалась опция `-0s`, полный отчёт представлен в предыдущем пункте

    Вывод: моя программа уступает всем по размеру файла, но короче по количеству строк всех, кроме программ с `-O1` и `-Os` опциями

+ *Представить в отчете полученные результаты, дополнив данные представленные в предыдущем отчете.*

    Результаты представлены в отчёте

## Дерево проекта

```
.
├── asm.exe                             # последняя скомпилированная версия ассемблерной программы
├── c.exe                               # последняя скомпилированная версия программы на С
├── form_array.c                        # вспомогательная единица компиляции программы на С
├── form_array.s                        # вспомогательная единица компиляции программы на ассемблере
├── input                               # файл с входными данными
├── main.c                              # главная единица компиляции программы на С
├── main.s                              # главная единица компиляции программы на ассемблере
├── Makefile                            # команды для работы с программой
├── optimization                        # директория с файлами для анализа опций оптимизации
│   ├── form_array_my.s
│   ├── form_array_non.s
│   ├── form_array_o0.s
│   ├── form_array_o1.s
│   ├── form_array_o2.s
│   ├── form_array_o3.s
│   ├── form_array_ofast.s
│   ├── form_array_os.s
│   ├── main_my.s
│   ├── main_non.s
│   ├── main_o0.s
│   ├── main_o1.s
│   ├── main_o2.s
│   ├── main_o3.s
│   ├── main_ofast.s
│   ├── main_os.s
│   ├── my.exe
│   ├── non.exe
│   ├── o0.exe
│   ├── o1.exe
│   ├── o2.exe
│   ├── o3.exe
│   ├── ofast.exe
│   └── os.exe
├── output                              # файл с выходными данными
├── README.md                           # отчёт
├── scripts                             # директория со скриптами
│   ├── compare-opt.sh                  # сравнительный анализ опций оптимизации
│   ├── compare.sh                      # сравнение скорости работы программ на С и на ассемблере
│   ├── compile-asm.sh                  # компиляция ассемблерной программы
│   ├── compile-c.sh                    # компиляция программы на С
│   ├── make-asm.sh                     # получение ассемблера
│   ├── optimize.sh                     # заполнение директории optimization/ соответствующими файлами
│   ├── rand-asm.sh                     # запуск ассемблерной программы с помощью генератора
│   ├── rand-c.sh                       # запуск программы на С с помощью генератора
│   ├── test-asm.sh                     # тестирование ассемблерной программы
│   └── test-c.sh                       # тестирование программы на С
├── stages                              # директория с ассемблерной программой сразу после получения
│   ├── form_array.bare.s
│   └── main.bare.s
└── tests                               # директория c тестами
    ├── test1.in
    ├── test1.out
    ├── test2.in
    ├── test2.out
    ├── test3.in
    ├── test3.out
    ├── test4.in
    └── test4.out
```

## Инструкции по запуску

Чтобы не заниматься копированием команд из блокнота в консоль, написала Makefile

Тестирование (работает долго, потому что прогоняется на больших тестах):
+ обеих программ:
    ```
    make test
    ```
+ ассемблерной прогрммы:
    ```
    make test.asm
    ```
+ программы на С:
    ```
    make test.c
    ```  

Компиляция (программы уже скомпилированы):
+ обеих программ:
    ```
    make compile
    ```
+ ассемблерной прогрммы:
    ```
    make compile.asm
    ```
+ программы на С:
    ```
    make compile.c
    ```  

Cравнение скорости работы программ на С и на ассемблере
```
make compare
``` 

Запуск с помощью генератора (не имеет смысла запускать обе, потому что они используют одни и те же файлы):
+ ассемблерной прогрммы:
    ```
    make rand.asm n=100
    ```
+ программы на С:
    ```
    make rand.c n=100
    ```  

Получение программ с помощью разных опций оптимизации (в директории `optimization/`):
```
make optimize
```

Сравнение программ с различными опциями оптимизации (работает долго, потому что прогоняется на больших тестах):
```
make compare.opt
```

Upd: в интерфейсе гитхаба у комментариев ассемблера поехала табуляция, делала в vscode, там всё красиво отображается

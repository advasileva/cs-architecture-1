# cs-architecture-1

## Задание

*Разработать программу, которая получает одномерный массив AN, после чего формирует из элементов массива A новый массив B по правилам, указанным в варианте, и выводит его. Память под массивы может выделяться статически, на стеке, автоматичеси по выбору разработчика. При решении задачи необходимо использовать подпрограммы для реализации ввода, вывода и формирования нового массива.*

*Вариант 25. Сформировать массив B из элементов массива A заменив все положительные числа значением 2, а отрицательные — увеличить на 5.*

## Отчёт

**Делала на оценку 8 баллов**

Для удобства проверки структурировала отчёт по критериям

### Структура проекта

```
.
├── asm.exe
├── c.exe
├── form_array.c
├── form_array.s
├── input
├── main.c
├── main.s
├── Makefile
├── output
├── README.md
├── scripts
│   ├── compare.sh
│   ├── compile-asm.sh
│   ├── compile-c.sh
│   ├── disasm.sh
│   ├── rand-asm.sh
│   ├── rand-c.sh
│   ├── test-asm.sh
│   └── test-c.sh
├── stages
│   ├── form_array.bare.s
│   └── main.bare.s
└── tests
    ├── test1.in
    ├── test1.out
    ├── test2.in
    ├── test2.out
    ├── test3.in
    └── test3.out
```

### 4 балла

+ *Приведено решение задачи на C.*

    Код на C находится в `main.c` и `form_array.c`

    Скомпилированная программа на C находится в `c.exe`

+ *В полученную ассемблерную программу, откомпилированную без оптимизирующих и отладочных опций, добавлены комментарии, поясняющие эквивалентное представление переменных в программе на C.*

    Прокомментированная ассемблерная программа находится в `main.s` и `form_array.s`

    Скомпилированная ассемблерная программа находится в `asm.exe`

+ *Из ассемблерной программы убраны лишние макросы за счет использования соответствующих аргументов командной строки и/или за счет ручного редактирования исходного текста ассемблерной программы.*

    Ассемблерная программа сразу после дизассемблирования находится в `stages/main.bare.s` и `stages/form_array.bare.s`

    Использованы соответствующие аргументы командной строки, которые указаны в `scripts/disasm.sh`

    Удалено из `main.s`:
    ```
    .file	"main.c"
    ```
    ```
	.ident	"GCC: (GNU) 10.3.1 20210703 (ALT Sisyphus 10.3.1-alt2)"
	.section	.note.GNU-stack,"",@progbits
    ```
    ```
	.type	main, @function
    ```
    ```
	.type	form_array, @function
    ```
    ```
	cdqe # знаковое расширение, входило 5 раз
    ```


    Удалено из `form_array.s`:
    ```
    .file	"form_array.c"
    ```
    ```
	.ident	"GCC: (GNU) 10.3.1 20210703 (ALT Sisyphus 10.3.1-alt2)"
	.section	.note.GNU-stack,"",@progbits
    ```
    ```
	cdqe # знаковое расширение, входило 6 раз
    ```

+ *Модифицированная ассемблерная программа отдельно откомпилирована и скомпонована без использования опций отладки.*

    Скомпилированная ассемблерная программа находится в `asm.exe`

+ *Представлено полное тестовое покрытие, дающее одинаковый результат на обоих программах. Приведены результаты тестовых прогонов для обоих программ, демонстрирующие эквивалентность функционирования.*

    Тесты находятся в `tests/`

    Их можно пронать с помощью:
    ```
    make test
    ```

+ *Сформировать отчет, описывающий результаты тестовых прогонов и используемых опций компиляции и/или описания проведенных модификаций.*

    Отчёт сформирован

### 5 баллов

+ *В реализованной программе использовать функции с передачей данных через параметры.*

    Функция `form_array(int n, int *A, int *B)` использует передачу данных через параметры

+ *Использовать локальные переменные.*

    Пример использования локальных переменных в `main.c`:
    ```
    int n;
    int i;
    struct timespec start;
    struct timespec finish;
    int64_t time_delta;
    FILE *input, *output;
    ```

+ *В ассемблерную программу при вызове функции добавить комментарии, описывающие передачу фактических параметров и перенос возвращаемого результата.*

    TBA

+ *В функциях для формальных параметров добавить комментарии, описывающие связь между параметрами языка Си и регистрами (стеком).*

    TBA

+ *Добавить информацию о проведенных изменениях в отчет.*

    TBA

### 6 баллов

+ *Рефакторинг программы на ассемблере за счет максимального использования регистров процессора. Добавление этой программы к уже представленным.*

    TBA

+ *Добавление комментариев в разработанную программу, поясняющих эквивалентное использование регистров вместо переменных исходной программы на C.*

    TBA

+ *Представление результатов тестовых прогонов для разработанной программы. Оценка корректности ее выполнения на основе сравнения тестовых прогонов результатами тестирования предшествующих программ.*

    TBA

+ *Добавить новую информацию в отчет.*

    TBA

### 7 баллов

+ *Реализация программы на ассемблере, полученной после рефакторинга, в виде двух или более единиц компиляции.*

    Использованы две единицы компиляции:
    + `main.s`
    + `form_array.s`

+ *Задание файлов с исходными данными и файла для вывода результатов с использованием аргументов командной строки.*

    Использованы аргументы командной строки для задания входного и выходного файлов:
    ```
    input = fopen(argv[2], "r");
    output = fopen(argv[3], "w");
    fscanf(input, "%d", &n);
    ```

+ *Добавить в отчет информацию о проделанных изменениях и результаты работы с тестовыми файлами.*

    TBA

### 8 баллов

+ *Добавление в программу генератора случайных наборов данных, расширяющих возможности тестирования. Подключение генератора к программе с выбором в командной строке варианта ввода данных.*

    Вариант ввода данных выбирается с помощью первого аргумента командной строки:
    + `0` - ввод из указанного во втором аргументе файла, вывод в указанный третьим аргументом файл
    + `1` - количество чисел в массиве задаётся вторым аргументом, сгенерированный массив А выводится в `input`, сформированный массив В выводится в `output`
 
    Получение размера массива:
    ```
    if (atoi(argv[1]) == 0) {
        input = fopen(argv[2], "r");
        output = fopen(argv[3], "w");
        fscanf(input, "%d", &n);
    } else {
        input = fopen("input", "w");
        output = fopen("output", "w");
        n = atoi(argv[2]);
    }
    ```

    Ввод массива А:
    ```
    if (atoi(argv[1]) == 0) {
        for(i = 0; i < n; i++) {
            fscanf(input, "%d", &A[i]);
        }
    } else {
        for(i = 0; i < n; i++) {
            A[i] = rand() % 200 - 100;
            fprintf(input, "%d ", A[i]);
    }
    ```

+ *Расширение анализа командной строки для выбора способа порождения исходных данных. Добавление данных, порождаемых генератором.*

    Описано в предыдущем пункте

+ *Модификация программы на C и программы на ассемблере, полученной после рефакторинга, для проведения сравнения на производительность. Необходимо добавить замеры во времени, которые не учитывают время ввода и вывода данных. Для увеличения времени работы минимум до 1 секунды, в зависимости от особенностей программы, можно либо выбирать соответствующие размеры исходных данных, либо зацикливать для многократного выполнения ту часть программы, которая выполняет вычисления.*

    Замер времени выполнения без ввода-вывода:
    ```
    clock_gettime(CLOCK_MONOTONIC, &start);

    for(i = 0; i < COUNT; i++) {
        form_array(n, A, B);
    }

    clock_gettime(CLOCK_MONOTONIC, &finish);

    time_delta = timeDelta(finish, start);
    printf("Time delta: %ld ns\n", time_delta);
    ```

    Вычисления программы выполняются `count = 100` раз

    Для вычисления времени работы используется функция
    ```
    int64_t timeDelta(struct timespec finish, struct timespec start)
    {
        int64_t nsecStart, nsecFinish;

        nsecStart = start.tv_sec;
        nsecStart *= 1000000000;
        nsecStart += start.tv_nsec;


        nsecFinish = finish.tv_sec;
        nsecFinish *= 1000000000;
        nsecFinish += finish.tv_nsec;

        return nsecFinish - nsecStart;
    }
    ```

+ *Представить полученные данные в отчете для разных вариантов тестовых прогонов*

    TBA
